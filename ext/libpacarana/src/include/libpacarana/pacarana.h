#ifndef _PACARANA_H_
#define _PACARANA_H_

/*
  @brief Used to change the state of a device
  @args
    -device needs to be the prefix for all of the objects referring to the
    device, e.g. "gyro" will access gyro_states and gyro_status
    -new_status needs to be a valid state from the user defined "device"_states
    enum
*/
#define STATE_CHANGE(device, new_status) \
 device ## _status = new_status;

/*
  @brief checks if the current state of the device matches the state it should
  be in
  @args
    -device needs to be the prefix for the object referring to the device
    -correct is the state the device should be in
  @returns returns a 1 if device is not in the correct state
*/
#define STATE_CHECK(device, correct) \
  (device ## _status == correct) ? 0 : 1

/*
  @brief dumps the current state
*/
#define STATE_READ(device) \
  device ## _status

/*
  @brief checks the adjacency matrix to see if the transition into this state is
         legal
  @args
    -device needs to be the prefix...
    -new_status is the status the program wants to transition into
  @returns a 1 if transition is not legal
*/
#define STATE_CHECK_ALL(device,new_status) \
  ((1 << device ## _status) & ~(device ## _state_adj[ new_status])) > 0


/*
  @brief checks if current status is in the allowed states, intended for use at
         start of a task
  @args
    -device needs to be the prefix...
    -map is a bitmask that contains 1s in the slots that are allowed. This can
    be generated by hand or offline
  @returns a 1 if device is in the wrong state
*/
#define STATE_OK(device,map) \
  ((1 << device ## _status) & ~(map)) > 0


/*
  @brief macro to register a function as a driver function that will affect
  peripheral state
*/
#define DRIVER __attribute__((annotate("periph")))

/*
  @brief macro to register a device as a peripheral
*/

#define REGISTER(device) \
  typedef uint32_t device ## _states; \
  device ## _states __attribute__((annotate("periph_var"))) device ## _status;


#endif
